/* (по желанию) Создайте SQL-запрос, который помещает в таблицу users миллион записей. */
-- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* 1. самый очевидный вариант - в цикле миллион раз сделать INSERT INTO users_test (name, age) VALUES ('abc', 123). Но и самый медленный. Я пробовал всего для 1000 раз,
заняло в моем случае примерно 2мин. Соответственно вставка миллиона записей по одной займет ориентировчно 2000 мин или более 33 часов

DROP PROCEDURE IF EXISTS add_1kk_items_while;
CREATE PROCEDURE add_1kk_items_while()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHILE i <= 1000 DO
		INSERT INTO users_test (name, age) VALUES ('abc', 123);
		SET i = i + 1;
	END WHILE;
END//

CALL add_1kk_items_while(); */
-- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* 2. самый быстрый вариант - загрузка из заранее подготовленного файла. Так загрузка через source сгенерированного в filldb файла на те же 1000 записей заняла в моем случае всего 0,2 сек. Объясняется это тем, что все 1000 записей загружаются одной командой.
-- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* 3. Отсюда делаем вывод - раз по условию нельзя пользоваться заранее сгенерированным файлом, то надо вставлять много записей за одну итерацию цикла. 
Причем в идеале весь миллион записей в одной команде)) 
Протестировал на вставке 1000 записей (по 100 штук за 10 проходов), заняло примерно 1,2 сек. Соответственно от цикла по 100 шт за 10 000 итераций ожидаю что-то в районе 1200 сек или 20 мин (не проверял)

DROP PROCEDURE IF EXISTS add_1kk_items;
CREATE PROCEDURE add_1kk_items()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHILE i <= 10 DO
		INSERT INTO users_test (name, age) VALUES 
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123);
		SET i = i + 1;
	END WHILE;
END//
-- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* 4. можно еще ускорить процесс используя промежуточную Memory-таблицу. Вставка тех же 1000 записей (по 100 за 10 итераций) заняла уже прим 0,40 сек. Значит для миллиона записей при тех же условиях потребуется около 7 минут*/

USE shop;

DROP TABLE IF EXISTS users_temp;
CREATE TABLE users_temp(
	id SERIAL PRIMARY KEY,
	name VARCHAR(10) NOT NULL,
	age TINYINT UNSIGNED
) ENGINE = MEMORY;

DELIMITER //

DROP PROCEDURE IF EXISTS add_1kk_items;
CREATE PROCEDURE add_1kk_items()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHILE i <= 10 DO
		INSERT INTO users_temp (name, age) VALUES 
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123),
			('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123), ('abc', 123);
		SET i = i + 1;
	END WHILE;
END//

DELIMITER ;

CALL add_1kk_items();

DROP TABLE IF EXISTS users_test;
CREATE TABLE users_test(
	id SERIAL PRIMARY KEY,
	name VARCHAR(10) NOT NULL,
	age TINYINT UNSIGNED
);

INSERT INTO users_test SELECT * FROM users_temp;
SELECT * FROM users_test ORDER BY id DESC LIMIT 5;

